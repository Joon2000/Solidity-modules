# Interface

## 학습 목표
- Interface의 개념을 이해한다.
- Interface의 특징 및 주의사항을 이해한다.
- 실제 예제를 통해 Interface를 선언하고 사용하는 방법을 학습한다.

## Interface 개념 설명

Solidity에서 Interface는 스마트 계약 간의 상호 작용을 정의하는 데 사용되는 중요한 개념이다. Interface는 스마트 계약이 어떻게 상호 작용할 수 있는지를 명확하게 정의하는 일종의 청사진을 제공한다. Interface는 함수 시그니처만 포함하고, 함수의 구현은 포함하지 않는다. 이는 다른 스마트 계약이 해당 인터페이스를 구현하는 방식을 강제하지 않으면서도 일관된 방법으로 상호 작용할 수 있게 한다.

## Interface의 특징

Interface는 다음과 같은 특징을 갖는다:

- **함수 시그니처만 포함**: Interface는 함수의 이름, 매개 변수 및 반환 타입만 정의하고, 함수의 구현은 포함하지 않는다.
- **상태 변수 및 생성자 정의 불가**: Interface는 상태 변수를 포함할 수 없으며, 생성자도 정의할 수 없다.
- **상속 가능**: Interface는 다른 Interface로부터 상속받을 수 있다.

## Abstract Contracts vs Interface

- **Abstract Contracts**: 최소한 하나의 구현되지 않은 함수를 포함하며, 직접 컴파일할 수 없다. 다른 계약이 이를 상속하여 사용할 수 있다.
- **Interface**: 어떠한 함수도 구현할 수 없으며, ABI가 표현할 수 있는 것에 제한된다. ABI와의 변환이 손쉽고 정보 손실이 없다.

## 예제 코드

다음은 Interface를 사용한 간단한 예제이다.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// 간단한 Counter를 구현한 contract
contract Counter {
    uint256 public count;

    function increment() external {
        count += 1;
    }
}

// Counter 계약의 interface로 호출 가능한 function들을 정의
interface ICounter {
    function count() external view returns (uint256);
    function increment() external;
}

// ICounter interface를 사용하여 Counter contract과 상호 작용하는 contract
contract MyContract {
    function incrementCounter(address _counter) external {
        ICounter(_counter).increment();
    }

    function getCount(address _counter) external view returns (uint256) {
        return ICounter(_counter).count();
    }
}

contract MockUniswapV2Factory {
    mapping(address => mapping(address => address)) public getPair;
    address public createdPair;

    function createPair(address tokenA, address tokenB) external returns (address pair) {
        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS');
        
        bytes memory bytecode = type(MockUniswapV2Pair).creationCode;
        bytes32 salt = keccak256(abi.encodePacked(token0, token1));
        assembly {
            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
        }
        
        MockUniswapV2Pair(pair).initialize(token0, token1);
        getPair[token0][token1] = pair;
        getPair[token1][token0] = pair;
        createdPair = pair;
        return pair;
    }
}

contract MockUniswapV2Pair {
    address public token0;
    address public token1;
    uint112 private reserve0;
    uint112 private reserve1;
    uint32 private blockTimestampLast;

    function initialize(address _token0, address _token1) external {
        token0 = _token0;
        token1 = _token1;
    }

    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function setReserves(uint112 _reserve0, uint112 _reserve1) external {
        reserve0 = _reserve0;
        reserve1 = _reserve1;
        blockTimestampLast = uint32(block.timestamp);
    }
}

contract UniswapExampleTest {
    MockUniswapV2Factory public factory;
    address public constant DAI = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    address public constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    constructor() {
        factory = new MockUniswapV2Factory();
        factory.createPair(DAI, WETH);
    }

    function getTokenReserves() external view returns (uint256 daiReserve, uint256 wethReserve) {
        address pair = factory.getPair(DAI, WETH);
        require(pair != address(0), "UniswapExample: DAI-WETH pair doesn't exist");

        (uint112 reserve0, uint112 reserve1,) = MockUniswapV2Pair(pair).getReserves();
        
        (daiReserve, wethReserve) = MockUniswapV2Pair(pair).token0() == DAI ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    function setReserves(uint112 _daiReserve, uint112 _wethReserve) external {
        address pair = factory.getPair(DAI, WETH);
        require(pair != address(0), "UniswapExample: DAI-WETH pair doesn't exist");

        if(MockUniswapV2Pair(pair).token0() == DAI) {
            MockUniswapV2Pair(pair).setReserves(_daiReserve, _wethReserve);
        } else {
            MockUniswapV2Pair(pair).setReserves(_wethReserve, _daiReserve);
        }
    }
}
```

### Counter 계약 설명

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// 간단한 Counter를 구현한 contract
contract Counter {
    uint256 public count;

    function increment() external {
        count += 1;
    }
}

// ICounter interface를 사용하여 Counter contract과 상호 작용하는 contract
interface ICounter {
    function count() external view returns (uint256);
    function increment() external;
}

contract MyContract {
    function incrementCounter(address _counter) external {
        ICounter(_counter).increment();
    }

    function getCount(address _counter) external view returns (uint256) {
        return ICounter(_counter).count();
    }
}
```

- `Counter` 계약은 `count` 상태 변수를 증가시키는 `increment` 함수를 포함한다.
- `ICounter` 인터페이스는 `Counter` 계약의 함수와 상호작용하기 위해 사용된다.
- `MyContract` 계약은 `ICounter` 인터페이스를 사용하여 `Counter` 계약과 상호작용하며, `incrementCounter` 함수를 통해 Counter 계약의 increment 함수를 호출하여 count 상태 변수를 증가시킨다.

### Uniswap 테스트 예제

```solidity
contract MockUniswapV2Factory {
    mapping(address => mapping(address => address)) public getPair;
    address public createdPair;

    function createPair(address tokenA, address tokenB) external returns (address pair) {
        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS');
        
        bytes memory bytecode = type(MockUniswapV2Pair).creationCode;
        bytes32 salt = keccak256(abi.encodePacked(token0, token1));
        assembly {
            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
        }
        
        MockUniswapV2Pair(pair).initialize(token0, token1);
        getPair[token0][token1] = pair;
        getPair[token1][token0] = pair;
        createdPair = pair;
        return pair;
    }
}

contract MockUniswapV2Pair {
    address public token0;
    address public token1;
    uint112 private reserve0;
    uint112 private reserve1;
    uint32 private blockTimestampLast;

    function initialize(address _token0, address _token1) external {
        token0 = _token0;
        token1 = _token1;
    }

    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function setReserves(uint112 _reserve0, uint112 _reserve1) external {
        reserve0 = _reserve0;
        reserve1 = _reserve1;
        blockTimestampLast = uint32(block.timestamp);
    }
}

contract UniswapExampleTest {
    MockUniswapV2Factory public factory;
    address public constant DAI = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    address public constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    constructor() {
        factory = new MockUniswapV2Factory();
        factory.createPair(DAI, WETH);
    }

    function getTokenReserves() external view returns (uint256 daiReserve, uint256 wethReserve) {
        address pair = factory.getPair(DAI, WETH);
        require(pair != address(0), "UniswapExample: DAI-WETH pair doesn't exist");

        (uint112 reserve0, uint112 reserve1,) = MockUniswapV2Pair(pair).getReserves();
        
        (daiReserve, wethReserve) = MockUniswapV2Pair(pair).token0() == DAI ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    function setReserves(uint112 _daiReserve, uint112 _wethReserve) external {
        address pair = factory.getPair(DAI, WETH);
        require(pair != address(0), "UniswapExample: DAI-WETH pair doesn't exist");

        if(MockUniswapV2Pair(pair).token0() == DAI) {
            MockUniswapV2Pair(pair).setReserves(_daiReserve, _wethReserve);
        } else {
            MockUniswapV2Pair(pair).setReserves(_wethReserve, _daiReserve);
        }
    }
}
```

- `MockUniswapV2Factory` 계약은 Uniswap V2 Factory의 모의 구현체이다.
  - `createPair` 함수를 통해 두 토큰의 페어를 생성하고, `getPair` 매핑을 통해 페어 주소를 저장 및 조회한다.
  - CREATE2 opcode를 사용하여 결정론적 주소로 페어 계약을 배포한다.

- `MockUniswapV2Pair` 계약은 Uniswap V2 Pair의 모의 구현체이다.
  - `initialize` 함수로 토큰 주소를 설정한다.
  - `getReserves` 함수로 현재 리저브 상태를 조회한다.
  - `setReserves` 함수로 리저브 상태를 설정할 수 있다 (테스트 목적).

- `UniswapExampleTest` 계약은 모의 Uniswap 환경을 설정하고 테스트하는 데 사용된다.
  - 생성자에서 `MockUniswapV2Factory`를 배포하고 DAI-WETH 페어를 생성한다.
  - `getTokenReserves` 함수는 DAI-WETH 페어의 현재 리저브 상태를 조회한다.
  - `setReserves` 함수는 테스트를 위해 DAI-WETH 페어의 리저브 상태를 설정한다.

이 코드는 Uniswap V2의 핵심 기능을 모방하여 로컬 테스트 환경에서 Uniswap 관련 로직을 테스트할 수 있게 해준다. 실제 Uniswap 컨트랙트와 상호작용하지 않고도 유사한 환경에서 개발 및 테스트가 가능하다.

## Remix에서 실습

1. [Remix IDE](https://remix.ethereum.org/)에 접속한다.
2. 새로운 Solidity 파일을 생성하여 예제 코드를 복사하여 붙여넣는다.
3. 코드를 컴파일하고 배포한다. (Counter, MyContract, UniswapExample만 배포하면 된다.)
4. 아래 버튼들이 제대로 동작하는지 확인한다.

- 아래는 deploy 후에 나오는 Counter contract의 결과 예시이다. count를 눌렀을 때, increment를 1회한 후 count를 조회하면 count가 하나 증가한 것을 확인할 수 있다. <br>
     <img src="https://github.com/Joon2000/Solidity-modules/blob/4f1081707e212cb84ee22643b2b51429108e319f/images/Interface/counter_count.png" width="400px" height="500px" title="count" alt="interface">
     <img src="https://github.com/Joon2000/Solidity-modules/blob/4f1081707e212cb84ee22643b2b51429108e319f/images/Interface/counter_increment_count.png" width="400px" height="500px" title="count" alt="interface">
 
- Deploy 진행 후, MyContract 계약을 사용하여 Counter 계약을 작동해본다. increment 1회한 후 count를 조회한 사진이다. MyContract를 통해 interface를 활용해 잘 구현된 것을 확인할 수 있다.  <br>
   <img src="https://github.com/Joon2000/Solidity-modules/blob/4f1081707e212cb84ee22643b2b51429108e319f/images/Interface/mycontract_count.png" width="400px" height="500px" title="count" alt="interface">

- MyContract를 통해 Counter를 increment한 후, getCount를 통해 증가된 값을 확인한다. 아래 이미지는 MyContract를 통해 increment한 후 count를 조회한 결과이다. <br>
   <img src="https://github.com/Joon2000/Solidity-modules/blob/4f1081707e212cb84ee22643b2b51429108e319f/images/Interface/mycontract_count_increment.png" width="400px" height="500px" title="count" alt="interface">

- uniswap interface를 활용해 DAI, WETH pair의 reserve를 설정하고 조회한다. <br>
  <img src="https://github.com/Joon2000/Solidity-modules/blob/10034643f8f15817bbbed15da47d03412c1057a0/images/Interface/interfaceuniswap2.png" width="300px" height="700px" title="interface" alt="interface">

